<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pathfinding Challenge Platformer - Adaptive</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
            font-family: sans-serif;
        }
        #gameCanvas {
            border: 2px solid #fff;
            background-color: #000;
        }
        #instructions {
            position: absolute;
            top: 20px;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="instructions">
        **Adaptive Bot:** Now knows its Max Jump limits.
        <br>
        **Next:** We need to implement the A* logic to use these limits for dynamic path generation.
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        // --- GAME CONSTANTS ---
        const GRAVITY = 0.5;
        const FRICTION = 0.8;
        const JUMP_POWER = -12; // Negative Y-velocity is up
        const TILE_SIZE = 20;
        const NODE_RADIUS = 3; 
        const REPLANNING_THRESHOLD = 60;

        // --- GAME OBJECTS ---
        let player = {
            x: 50, y: 550, w: TILE_SIZE, h: TILE_SIZE, color: 'blue',
            velX: 0, velY: 0, isJumping: false, speed: 5
        };

        let bot = {
            x: 730, y: 550, w: TILE_SIZE, h: TILE_SIZE, color: 'red',
            velX: 0, velY: 0, isJumping: false, speed: 4,
            path: [], currentStep: 0, targetX: 730, targetY: 550, currentAction: 'walk',
            stuckTimer: 0, 
            lastPosition: { x: 730, y: 550 }
        };

        const platforms = [
            { id: 0, x: 0, y: 570, w: 800, h: 30, color: '#2ecc71' }, 
            { id: 1, x: 150, y: 450, w: 100, h: 20, color: '#95a5a6' }, 
            { id: 2, x: 400, y: 350, w: 150, h: 20, color: '#95a5a6' }, 
            { id: 3, x: 650, y: 250, w: 80, h: 20, color: '#95a5a6' }   
        ];
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;


        // ----------------------------------------------------------------------
        // --- PATHFINDING DATA STRUCTURES and CLASS ---
        // ----------------------------------------------------------------------
        
        class PlatformPathfinder {
            constructor(platforms, bot) {
                this.platforms = platforms;
                this.bot = bot;
                this.navNodes = this.generateNavNodes();
                
                // --- CALCULATE BOT'S MAX JUMP ABILITY ---
                // Max vertical height the bot can reach from jump start (up to apex)
                // H_max = (V_initial^2) / (2 * G)
                this.maxJumpHeight = Math.pow(JUMP_POWER, 2) / (2 * GRAVITY);
                
                // Max horizontal distance the bot can cover 
                // Time to reach apex (T_up): T_up = V_initial / G
                const timeToApex = Math.abs(JUMP_POWER) / GRAVITY;
                // Total flight time (T_flight): T_flight = 2 * T_up
                const totalFlightTime = 2 * timeToApex;
                // D_max = V_horizontal * T_flight (Assuming V_horizontal = bot.speed)
                this.maxJumpDistance = bot.speed * totalFlightTime;

                console.log(`Bot Max Jump Height: ${this.maxJumpHeight.toFixed(1)}px`);
                console.log(`Bot Max Jump Distance: ${this.maxJumpDistance.toFixed(1)}px`);
            }

            generateNavNodes() {
                // ... (Node generation logic remains the same) ...
                const nodes = [];
                const padding = 10;
                for (const p of this.platforms) {
                    const nodeY = p.y - this.bot.h;
                    nodes.push({ x: p.x + padding, y: nodeY, platformId: p.id, isEdge: true });
                    nodes.push({ x: p.x + p.w - padding, y: nodeY, platformId: p.id, isEdge: true });
                    if (p.w > 200) { nodes.push({ x: p.x + p.w / 2, y: nodeY, platformId: p.id, isEdge: false }); }
                }
                return nodes;
            }
            
            /**
             * Checks if a jump from Node A (x1, y1) to Node B (x2, y2) is possible.
             */
            canJump(x1, y1, x2, y2) {
                const dx = Math.abs(x2 - x1);
                const dy = y1 - y2; // Positive means jumping up, negative means jumping down

                // Can the bot walk there? (No need to jump)
                if (Math.abs(dy) < 5 && dx < this.bot.w) {
                    return true;
                }

                // Check Horizontal Limit
                if (dx > this.maxJumpDistance) {
                    return false; // Too far horizontally
                }

                // Check Vertical Limit (only need to check UPWARD jumps)
                if (dy > this.maxJumpHeight + 5) { // Add a buffer of 5px
                    return false; // Too high vertically
                }
                
                // Check if target is a safe landing spot (within the platforms defined bounds)
                // (Advanced check involving checking for obstacles in the arc is skipped for simplicity)

                // If it passes simple limits, assume a jump is possible for now.
                return true;
            }


            /**
             * The core A* search function.
             * This MUST be replaced with full A* logic to solve the user's problem.
             */
            findPath(startX, startY, endX, endY) {
                // Reset the bot's movement state before starting a new path:
                this.bot.currentStep = 0;
                this.bot.stuckTimer = 0;
                
                // ------------------------------------------------------
                // *** CHALLENGE: IMPLEMENT A* HERE ***
                // ------------------------------------------------------
                
                // For now, we return a test path from the current start point
                // that uses the new canJump check to decide the action:
                
                const testPath = [
                    { x: 130, y: H - 30 - this.bot.h, action: 'walk' },
                    { x: 190, y: 450 - this.bot.h, action: this.canJump(130, H - 30 - this.bot.h, 190, 450 - this.bot.h) ? 'jump' : 'walk' }, 
                    { x: 230, y: 450 - this.bot.h, action: 'walk' }, 
                    { x: 230, y: H - 30 - this.bot.h, action: this.canJump(230, 450 - this.bot.h, 230, H - 30 - this.bot.h) ? 'jump' : 'walk' },
                    { x: 730, y: H - 30 - this.bot.h, action: 'walk' } 
                ];
                
                return testPath;
            }
        }

        const pathfinder = new PlatformPathfinder(platforms, bot);

        // --- Initialize Bot Path ---
        bot.path = pathfinder.findPath(bot.x, bot.y, player.x, player.y);
        if (bot.path.length > 0) {
            bot.targetX = bot.path[0].x;
            bot.targetY = bot.path[0].y;
            bot.currentAction = bot.path[0].action;
        }


        // ----------------------------------------------------------------------
        // --- GAME ENGINE AND PHYSICS & DRAW (Code remains the same) ---
        // ----------------------------------------------------------------------
        
        let keys = {};
        window.addEventListener('keydown', (e) => { keys[e.key] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key] = false; });

        function checkCollision(objA, objB) {
            return objA.x < objB.x + objB.w && objA.x + objA.w > objB.x &&
                   objA.y + objA.h > objB.y && objA.y < objB.y + objB.h;
        }
        
        function applyPhysicsAndCollision(entity) {
            entity.velY += GRAVITY;
            entity.velX *= FRICTION; 
            if (Math.abs(entity.velX) < 0.5) entity.velX = 0;
            entity.x += entity.velX;
            entity.y += entity.velY;

            for (let p of platforms) {
                if (checkCollision(entity, p)) {
                    if (entity.velY > 0 && entity.y + entity.h - entity.velY <= p.y) {
                        entity.y = p.y - entity.h; entity.velY = 0; entity.isJumping = false;
                    } else if (entity.y + entity.h > p.y && entity.y < p.y + p.h) {
                        entity.x -= entity.velX; entity.velX = 0;
                        if (entity.velY < 0) { entity.y = p.y + p.h; entity.velY = 0; }
                    }
                }
            }
            if (entity.x < 0) entity.x = 0;
            if (entity.x + entity.w > W) entity.x = W - entity.w;
        }

        function updatePlayer() {
            if (keys['ArrowRight']) { player.velX = player.speed; } 
            else if (keys['ArrowLeft']) { player.velX = -player.speed; } 
            if (keys['ArrowUp'] && !player.isJumping) { player.velY = JUMP_POWER; player.isJumping = true; }
            applyPhysicsAndCollision(player);
        }

        function updateBot() {
            let entity = bot;
            
            const distanceMoved = Math.sqrt(
                Math.pow(entity.x - entity.lastPosition.x, 2) + 
                Math.pow(entity.y - entity.lastPosition.y, 2)
            );

            // Re-planning Logic: If stuck for too long, generate a new path from current location
            if (entity.path.length > 0 && distanceMoved < 0.5) {
                entity.stuckTimer++;
                if (entity.stuckTimer > REPLANNING_THRESHOLD) {
                    console.warn("Bot is stuck or path failed! Re-planning...");
                    // Re-plan from the current stuck location to the player's location
                    entity.path = pathfinder.findPath(entity.x, entity.y, player.x, player.y);
                    if (entity.path.length > 0) {
                        entity.targetX = entity.path[0].x;
                        entity.targetY = entity.path[0].y;
                        entity.currentAction = entity.path[0].action;
                    } else { entity.velX = 0; }
                }
            } else { entity.stuckTimer = 0; }
            
            entity.lastPosition.x = entity.x;
            entity.lastPosition.y = entity.y;
            
            
            // Movement Execution
            if (entity.currentStep >= entity.path.length) { entity.velX = 0; return; } 

            const target = entity.path[entity.currentStep];
            const reachedX = Math.abs(entity.x - target.x) < 5;
            const reachedY = Math.abs(entity.y - target.y) < 5 && !entity.isJumping;

            if (reachedX && reachedY) {
                entity.currentStep++;
                if (entity.currentStep < entity.path.length) {
                    const nextTarget = entity.path[entity.currentStep];
                    entity.targetX = nextTarget.x;
                    entity.targetY = nextTarget.y;
                    entity.currentAction = nextTarget.action;
                } else { entity.velX = 0; return; }
            }
            
            if (entity.currentAction === 'walk') {
                if (entity.x < entity.targetX) { entity.velX = entity.speed; } 
                else if (entity.x > entity.targetX) { entity.velX = -entity.speed; } 
                else { entity.velX = 0; }
            } else if (entity.currentAction === 'jump') {
                if (!entity.isJumping) { entity.velY = JUMP_POWER; entity.isJumping = true; }
                if (entity.x < entity.targetX) { entity.velX = entity.speed * 0.7; } 
                else if (entity.x > entity.targetX) { entity.velX = -entity.speed * 0.7; }
            }
            
            applyPhysicsAndCollision(entity);
        }

        function draw() {
            ctx.clearRect(0, 0, W, H);
            for (let p of platforms) { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.w, p.h); }
            
            // Draw Navigation Nodes
            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            for (const node of pathfinder.navNodes) {
                ctx.beginPath();
                ctx.arc(node.x + TILE_SIZE / 2, node.y + TILE_SIZE / 2, NODE_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw Bot's Planned Path
            if (bot.path.length > 0) {
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(bot.x + bot.w / 2, bot.y + bot.h / 2);
                for (let i = bot.currentStep; i < bot.path.length; i++) {
                    const step = bot.path[i];
                    ctx.lineTo(step.x + bot.w / 2, step.y + bot.h / 2);
                }
                ctx.stroke();

                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(bot.targetX + bot.w / 2, bot.targetY + bot.h / 2, NODE_RADIUS * 2, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.w, player.h);
            ctx.fillStyle = bot.color;
            ctx.fillRect(bot.x, bot.y, bot.w, bot.h);
        }

        // Main game loop
        function gameLoop() {
            updatePlayer();
            updateBot();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start the game!
        gameLoop();
    </script>
</body>
</html>
