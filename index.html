<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pathfinding Challenge Platformer - Visualized</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
            font-family: sans-serif;
        }
        #gameCanvas {
            border: 2px solid #fff;
            background-color: #000;
        }
        #instructions {
            position: absolute;
            top: 20px;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="instructions">
        **PLAYER (Blue):** Arrow Keys.
        <br>
        **BOT's Thinking (Yellow/Green):** Shows the current path and navigation nodes.
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        // --- GAME CONSTANTS ---
        const GRAVITY = 0.5;
        const FRICTION = 0.8;
        const JUMP_POWER = -12;
        const TILE_SIZE = 20;
        const NODE_RADIUS = 3; // Size of the drawn navigation node

        // --- GAME OBJECTS ---
        let player = {
            x: 50, y: 550, w: TILE_SIZE, h: TILE_SIZE, color: 'blue',
            velX: 0, velY: 0, isJumping: false, speed: 5
        };

        let bot = {
            x: 730, y: 550, w: TILE_SIZE, h: TILE_SIZE, color: 'red',
            velX: 0, velY: 0, isJumping: false, speed: 4,
            path: [], currentStep: 0, targetX: 730, targetY: 550, currentAction: 'walk'
        };

        const platforms = [
            { id: 0, x: 0, y: 570, w: 800, h: 30, color: '#2ecc71' }, // Ground
            { id: 1, x: 150, y: 450, w: 100, h: 20, color: '#95a5a6' }, // Platform 1
            { id: 2, x: 400, y: 350, w: 150, h: 20, color: '#95a5a6' }, // Platform 2
            { id: 3, x: 650, y: 250, w: 80, h: 20, color: '#95a5a6' }   // Platform 3
        ];
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;


        // ----------------------------------------------------------------------
        // --- PATHFINDING DATA STRUCTURES (A* Implementation Shell) ---
        // ----------------------------------------------------------------------
        
        // (Node and PriorityQueue classes remain the same as before, omitted for brevity)

        /**
         * The main Pathfinder class, now including Node generation for visualization.
         */
        class PlatformPathfinder {
            constructor(platforms, bot) {
                this.platforms = platforms;
                this.bot = bot;
                this.navNodes = this.generateNavNodes();
            }

            /**
             * Generates simple walk/jump points on the platforms for visualization.
             * This creates the "map" the bot thinks about.
             */
            generateNavNodes() {
                const nodes = [];
                const padding = 10; // Distance from edge to place a node

                for (const p of this.platforms) {
                    const nodeY = p.y - this.bot.h; // Node Y is at the height the bot stands at

                    // Left Edge Node
                    nodes.push({ 
                        x: p.x + padding, 
                        y: nodeY, 
                        platformId: p.id,
                        isEdge: true
                    });

                    // Right Edge Node
                    nodes.push({ 
                        x: p.x + p.w - padding, 
                        y: nodeY, 
                        platformId: p.id,
                        isEdge: true
                    });
                    
                    // Center Node (for long platforms)
                    if (p.w > 200) {
                         nodes.push({ 
                            x: p.x + p.w / 2, 
                            y: nodeY, 
                            platformId: p.id,
                            isEdge: false
                        });
                    }
                }
                return nodes;
            }

            /**
             * The core A* search function.
             * @returns An array of {x, y, action} objects.
             */
            findPath(startX, startY, endX, endY) {
                // ------------------------------------------------------
                // *** This function still returns a hardcoded path ***
                // You will replace this with the A* logic later.
                // ------------------------------------------------------
                
                console.log("A* Search triggered. Returning test path...");
                
                return [
                    { x: 130, y: H - 30 - this.bot.h, action: 'walk' },
                    { x: 190, y: 450 - this.bot.h, action: 'jump' }, 
                    { x: 230, y: 450 - this.bot.h, action: 'walk' }, 
                    { x: 230, y: H - 30 - this.bot.h, action: 'jump' },
                    { x: 730, y: H - 30 - this.bot.h, action: 'walk' } 
                ];
            }
        }

        const pathfinder = new PlatformPathfinder(platforms, bot);

        // --- Initialize Bot Path ---
        bot.path = pathfinder.findPath(bot.x, bot.y, player.x, player.y);
        if (bot.path.length > 0) {
            bot.targetX = bot.path[0].x;
            bot.targetY = bot.path[0].y;
            bot.currentAction = bot.path[0].action;
        }


        // ----------------------------------------------------------------------
        // --- GAME ENGINE AND PHYSICS (Code remains the same as before) ---
        // ----------------------------------------------------------------------

        let keys = {};
        window.addEventListener('keydown', (e) => { keys[e.key] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key] = false; });

        function checkCollision(objA, objB) {
            return objA.x < objB.x + objB.w && objA.x + objA.w > objB.x &&
                   objA.y + objA.h > objB.y && objA.y < objB.y + objB.h;
        }
        
        function applyPhysicsAndCollision(entity) {
            // Apply gravity and friction
            entity.velY += GRAVITY;
            entity.velX *= FRICTION; 
            if (Math.abs(entity.velX) < 0.5) entity.velX = 0;

            entity.x += entity.velX;
            entity.y += entity.velY;

            // Collision Detection (simplified)
            for (let p of platforms) {
                if (checkCollision(entity, p)) {
                    if (entity.velY > 0 && entity.y + entity.h - entity.velY <= p.y) {
                        entity.y = p.y - entity.h;
                        entity.velY = 0;
                        entity.isJumping = false;
                    } else if (entity.y + entity.h > p.y && entity.y < p.y + p.h) {
                        entity.x -= entity.velX; entity.velX = 0;
                        if (entity.velY < 0) { entity.y = p.y + p.h; entity.velY = 0; }
                    }
                }
            }
            
            // Wall/Screen Boundary Check
            if (entity.x < 0) entity.x = 0;
            if (entity.x + entity.w > W) entity.x = W - entity.w;
        }

        function updatePlayer() {
            if (keys['ArrowRight']) { player.velX = player.speed; } 
            else if (keys['ArrowLeft']) { player.velX = -player.speed; } 
            if (keys['ArrowUp'] && !player.isJumping) { player.velY = JUMP_POWER; player.isJumping = true; }
            applyPhysicsAndCollision(player);
        }

        function updateBot() {
            let entity = bot;
            if (entity.currentStep >= entity.path.length) { entity.velX = 0; return; } 

            const target = entity.path[entity.currentStep];
            const reachedX = Math.abs(entity.x - target.x) < 5;
            const reachedY = Math.abs(entity.y - target.y) < 5 && !entity.isJumping;

            if (reachedX && reachedY) {
                entity.currentStep++;
                if (entity.currentStep < entity.path.length) {
                    const nextTarget = entity.path[entity.currentStep];
                    entity.targetX = nextTarget.x;
                    entity.targetY = nextTarget.y;
                    entity.currentAction = nextTarget.action;
                } else { entity.velX = 0; return; }
            }
            
            if (entity.currentAction === 'walk') {
                if (entity.x < entity.targetX) { entity.velX = entity.speed; } 
                else if (entity.x > entity.targetX) { entity.velX = -entity.speed; } 
                else { entity.velX = 0; }
            } else if (entity.currentAction === 'jump') {
                if (!entity.isJumping) { entity.velY = JUMP_POWER; entity.isJumping = true; }
                if (entity.x < entity.targetX) { entity.velX = entity.speed * 0.7; } 
                else if (entity.x > entity.targetX) { entity.velX = -entity.speed * 0.7; }
            }
            applyPhysicsAndCollision(entity);
        }


        // ----------------------------------------------------------------------
        // --- DRAW FUNCTION (New Visualization) ---
        // ----------------------------------------------------------------------

        function draw() {
            ctx.clearRect(0, 0, W, H);

            // 1. Draw Platforms
            for (let p of platforms) {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.w, p.h);
            }
            
            // 2. Draw Navigation Nodes (The Bot's "Map")
            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)'; // Semi-transparent green
            for (const node of pathfinder.navNodes) {
                ctx.beginPath();
                ctx.arc(node.x + TILE_SIZE / 2, node.y + TILE_SIZE / 2, NODE_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            }

            // 3. Draw Bot's Planned Path (The Bot's "Thinking")
            if (bot.path.length > 0) {
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                // Start the line at the bot's current position
                ctx.moveTo(bot.x + bot.w / 2, bot.y + bot.h / 2);
                
                // Draw line segments for the rest of the path
                for (let i = bot.currentStep; i < bot.path.length; i++) {
                    const step = bot.path[i];
                    ctx.lineTo(step.x + bot.w / 2, step.y + bot.h / 2);
                }
                ctx.stroke();

                // Draw current target as a highlighted circle
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(bot.targetX + bot.w / 2, bot.targetY + bot.h / 2, NODE_RADIUS * 2, 0, Math.PI * 2);
                ctx.fill();
            }


            // 4. Draw Player and Bot
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.w, player.h);

            ctx.fillStyle = bot.color;
            ctx.fillRect(bot.x, bot.y, bot.w, bot.h);
        }

        // Main game loop
        function gameLoop() {
            updatePlayer();
            updateBot();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start the game!
        gameLoop();

    </script>
</body>
</html>
